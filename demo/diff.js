/*
** 前面我们提到jd的新的类react框架nerv，并在数据结构/算法/api等当面将两者进行了比较。
** 这里我们大概介绍了react的diff算法以及nerv针对这块内容，做的优化
*/

/*
** react的diff算法
拿两个数组的比较来介绍diff算法的基本过程
A: [a, b, c, d, e, f, g]
B: [a, c, b, h, f, e, g]
按照react的diff算法，会先找到相同的前置元素和后置元素。这里相同的前置是a；后置元素是g。这时候就可以应用之前的
优化策略，将问题简化为diff下面两个数组
A: [b, c, d, e, f]
B: [c, b, h, f, e]
我们的问题的核心就是找到：被删除or插入or移动的元素
我们创造一个数组P，用它来新数组应该被插入的位置。同时创建一个索引I，作为新数组B的映射;定义一个last标识数组A中
访问过的节点在A中最右的位置:
A: [b, c, d, e, f]
B: [c, b, h, f, e]
P: [. . . . .]
I: {
  c: 0,
  b: 1,
  h: 2,
  f: 3, 
  e: 4,
}
然后对A进行元素的遍历，被选中的元素看B中有没有，没有就移除掉；有的话将该元素在A中的位置放置到数组P中对应的位置：

第一次遍历：b，存在于B中，放到P中对应位置
A: [b, c, d, e, f]
B: [c, b, h, f, e]
P: [.  0 . . .]
last = 0；（不移动）
第二次遍历：c，存在于B中，放到P中对应位置
A: [b, c, d, e, f]
B: [c, b, h, f, e]
P: [1, 0 . . .]
last = 1; （移动）
第三次遍历：d，不在B中，被移除
A: [b, c, d, e, f]
B: [c, b, h, f, e]
P: [1, 0 . . .]
last = 2 （移除）
第四次遍历：e，存在于B中，放到P中对应位置
A: [b, c, d, e, f]
B: [c, b, h, f, e]
P: [1, 0 . . 3]
last = 3 （不移动）
第五次遍历：f，存在于B中，放到P中对应位置
A: [b, c, d, e, f]
B: [c, b, h, f, e]
P: [1, 0 . 4, 3]
last = 4 （不移动）
这里diff算法的核心：每次遍历的时候将当前被遍历元素在B中位置和last进行对比。
比last，就被添加到差异队列；否则会进行位置移动。

到这里react的diff算法已经完成。然后就是针对性的进行重新渲染

nerv这里还会进行优化（最终是要实现最小的移动次数），这里我们需要找到P数组的最长递增子序列LIS来做动态规划，
不属于这个最长递增子序列的将会被移动或是新增，删除
继续上面的操作
A: [b, c, d, e, f]
B: [c, b, h, f, e]
P: [1, 0 . 4, 3]
LIS: [1, 4]
然后针对0, ., 3这几个元素进行重新移动或是新增，减轻了渲染的元素数量。
*/

/** EXAMPLE
 * 就拿下面两个数组来做对比：
 * A: [a, b, c, d]
 * B: [d, a, b, c]
 * 
 * 如果这里使用react的diff算法，需要进行3次操作；
 * 使用nerv的动态规划之后
 * A: [a, b, c, d]
 * B: [d, a, b, c]
 * P: [3, 0, 1, 2]
 * LIS: [0, 1, 2]
 * 只需要将d移动到头部位置就可以完成diff，一次操作就行
 */